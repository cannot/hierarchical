<?php

namespace samyapp\hierarchical;

/**
 * Workflow:
 * 1) Build the tree, from some form of iterable
 * 2) Create an output array from the tree
 * 3) Convert that array to a suitable output format
 */
class Builder
{
	/**
	 * @var string The name of the key to use to indicate the depth of each node in input data
	 */
	public $inputDepthKey = 'depth';

	/**
	 * @var int The maximum depth to include nodes up to
	 */
	public $maxDepth = 0xffffff;

	/**
	 * Build a tree from an iterable collection of array data, storing depth and number
	 * of children in each node.
	 * Each entry in the collection must represent a node in the tree,
	 * and entries must be in the order generated by a depth-first walk of the tree.
	 * e.g. 
	 * -1
	 *  -1.1
	 *   -1.1.1
	 *   - 1.1.2
	 *  -1.2
	 * -2
	 * @return Node The "root" of a forest of (possibly just one) tree(s)
	 */
	public function build($iterable)
	{
		$tree = new Node();
		$prev_depth = 0;
		$stack = array($tree);
		foreach( $iterable as $item) {
			$depth = $item[$this->inputDepthKey];
			if ($depth > $this->maxDepth) {
				continue;
			}
			$data = $item;
			unset($data[$this->inputDepthKey]);
			if ($depth == $prev_depth) { // sibling 
				$stack[$depth-1]->children[] = $stack[$depth] = new Node($data, $depth);
			}
			else if ($depth < $prev_depth) {
				$stack[$depth-1]->children[] = $stack[$depth] = new Node($data, $depth);
			}
			else { // descendant of previous line
				$stack[$prev_depth]->children[] = $stack[$depth] = new Node($data, $depth);
			}
			$prev_depth = $depth;
			for ($i = 0; $i < $prev_depth; ++$i) {
				$stack[$i]->totalDescendents++;
			}
		}
		return $tree;
	}

	/**
	 * Walk through the tree, depth-first, converting it into an output array
	 * through repeatedly calling the transformer's 'next' method on each node.
	 */
	public function walk($node, $transformer, &$output_array)
	{
		foreach ($node->children as $item) {
			$transformer->next($item, $output_array);
			$this->walk($item, $transformer, $output_array);
		}
	}

}


